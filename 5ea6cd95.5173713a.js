(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{114:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return i})),t.d(n,"rightToc",(function(){return d})),t.d(n,"default",(function(){return u}));var r=t(2),l=t(6),a=(t(0),t(124)),o={id:"trees",title:"Trees",sidebar_label:"Trees"},i={id:"data-structures/trees",title:"Trees",description:"A tree is a data structure where a node can have zero or more children",source:"@site/docs/data-structures/trees.md",permalink:"/docs/data-structures/trees",editUrl:"https://github.com/ajmhyd/studyguide/edit/master/website/docs/data-structures/trees.md",sidebar_label:"Trees",sidebar:"someSidebar",previous:{title:"Stacks",permalink:"/docs/data-structures/stacks"},next:{title:"Queues",permalink:"/docs/data-structures/queues"}},d=[{value:"Binary Trees",id:"binary-trees",children:[{value:"Full Binary Trees",id:"full-binary-trees",children:[]},{value:"Complete Binary Trees",id:"complete-binary-trees",children:[]},{value:"Perfect Binary Tree",id:"perfect-binary-tree",children:[]},{value:"Binary Search Tree",id:"binary-search-tree",children:[]}]},{value:"Code",id:"code",children:[]}],c={rightToc:d};function u(e){var n=e.components,t=Object(l.a)(e,["components"]);return Object(a.b)("wrapper",Object(r.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("p",null,"A tree is a data structure where a node can have zero or more children"),Object(a.b)("p",null,"The top-most node is called the root"),Object(a.b)("p",null,"The DOM, or document object model, is a tree data structure"),Object(a.b)("p",null,"A node without children is called a leaf node"),Object(a.b)("p",null,"The height of a tree is the distance between the farthest leaf node and the root node"),Object(a.b)("h2",{id:"binary-trees"},"Binary Trees"),Object(a.b)("p",null,"Binary trees are a special type of tree in which each node can only have a maximum of two children: a left child and a right child"),Object(a.b)("h3",{id:"full-binary-trees"},"Full Binary Trees"),Object(a.b)("p",null,"A full binary tree is a binary tree in which every node has exactly zero or two children ",Object(a.b)("em",{parentName:"p"},"but never one")),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),"   O\n  / \\\n O   O\n    / \\\n   O   O\n  / \\\n O   O\n")),Object(a.b)("h3",{id:"complete-binary-trees"},"Complete Binary Trees"),Object(a.b)("p",null,"A complete binary tree is a binary tree in which all levels except the last one are full with nodes"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),"          O\n        /   \\\n       O     O\n      / \\   / \\\n     O   O O   O\n    /\\   /\\\n   O  O O  O\n")),Object(a.b)("h3",{id:"perfect-binary-tree"},"Perfect Binary Tree"),Object(a.b)("p",null,"A perfect binary tree is a binary tree in which all levels, including the last level, are full of nodes"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),"          O\n        /   \\\n       O     O\n      / \\   / \\\n     O   O O   O\n")),Object(a.b)("h3",{id:"binary-search-tree"},"Binary Search Tree"),Object(a.b)("p",null,"A binary search tree is a special type of binary tree where the values of every node to the left are less than its value and the values of every node to the right are greater than its value"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),"    10\n   /  \\\n  7    12\n / \\     \\\n3   9     14\n")),Object(a.b)("h2",{id:"code"},"Code"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),'class Node {\n  constructor(value) {\n    this.value= value;\n    this.leftChild = null;\n    this.rightChild = null;\n  }\n}\n\nclass BinaryTree {\n  constructor() {\n    this.root = null;\n  }\n\n  addChild(value) {\n    if(this.root === null) {\n      this.root = new Node(value);\n      return;\n    } else {\n      let currentNode = this.root;\n      let added = false;\n\n      while(!added && currentNode) {\n        if (value === currentNode.value) {\n          return "Duplicates cannot be added";\n        }\n\n        if (value < currentNode.value) {\n          if (currentNode.leftChild === null) {\n            currentNode.leftChild = new Node(value);\n            added = true;\n          } else {\n            currentNode = currentNode.leftChild;\n          }\n        } else if (value > currentNode.value) {\n          if (currentNode.rightChild === null) {\n            currentNode.rightChild = new Node(Value)\n            added = true;\n          } else {\n            currentNode = currentNode.rightChild;\n          }\n        }\n      }\n    }\n  }\n\n  removeChild(value) {\n    let currentNode = this.root;\n    let found = false;\n    let nodeToRemove;\n    let parentNode = null;\n\n    while(!found) {\n      if (currentNode === null || current.value === null) {\n        return "The node was not found";\n      }\n      if (value === currentNode.value) {\n        nodeToRemove = currentNode;\n        found = true;\n      } else if (value < currentNode.value) {\n        parentNode = currentNode;\n        currentNode = currentNode.leftChild;\n      } else {\n        parentNode = currentNode;\n        currentNode = currentNode.rightChild;\n      }\n    }\n\n    const nodeToRemoveIsParentsLeftChild = parentNode.leftChild === nodeToRemove;\n    // If nodeToRemove is a leaf node\n    if (nodeToRemove.leftChild === null && nodeToRemove.rightChild === null) {\n      if (nodeToRemoveIsParentsLeftChild) {\n        parentNode.leftChild = null;\n      } else {\n        parentNode.rightChild = null;\n      }\n    } else if (nodeToRemove.leftChild !== null && nodeToRemove.rightChild === null) {\n      // Only has a left child\n      if (nodeToRemoveIsParentLeftChild) {\n        parentNode.leftChild = nodeToRemove.leftChild;\n      } else {\n        parentNode.rightChild = nodeToRemove.leftChild;\n      }\n    } else if (nodeToRemove.rightChild !== null && nodeToRemove.leftChild === null) {\n      // Only has a right child\n      if (nodeToRemoveIsParentsLeftChild) {\n        parentNode.leftChild = nodeToRemove.rightChild;\n      } else {\n        parentNode.rightChild = nodeToRemove.rightChild;\n      }\n    } else {\n      // Has two children\n      const rightSubTree = nodeToRemove.rightChild;\n      const leftSubTree = nodeToRemove.leftChild;\n      // set parent node\'s respective child to the right subtree\n      if (nodeToRemoveIsParentsLeftChild) {\n        parentNode.leftChild = rightSubTree;\n      } else {\n        ParentNode.rightChild = rightSubTree;\n      }\n\n      // Find the lowest free space on the left side of the right subtree and add the leftSubTree\n      let currentLeftNode = rightSubTree;\n      let currentLeftParent;\n      let foundSpace = false;\n      while (!foundSpace) {\n        if (currentLeftNode === null) {\n          foundSpace = true;\n        } else {\n          currentLeftParent = currentLeftNode;\n          currentLeftNode = currentLeftNode.leftChild;\n        }\n      }\n      currentLeftParent.leftChild = leftSubTree;\n      return "The node was successfully deleted";\n    }\n  }\n}\n\n')))}u.isMDXComponent=!0},124:function(e,n,t){"use strict";t.d(n,"a",(function(){return s})),t.d(n,"b",(function(){return b}));var r=t(0),l=t.n(r);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function d(e,n){if(null==e)return{};var t,r,l=function(e,n){if(null==e)return{};var t,r,l={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var c=l.a.createContext({}),u=function(e){var n=l.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},s=function(e){var n=u(e.components);return l.a.createElement(c.Provider,{value:n},e.children)},h={inlineCode:"code",wrapper:function(e){var n=e.children;return l.a.createElement(l.a.Fragment,{},n)}},f=l.a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,o=e.parentName,c=d(e,["components","mdxType","originalType","parentName"]),s=u(t),f=r,b=s["".concat(o,".").concat(f)]||s[f]||h[f]||a;return t?l.a.createElement(b,i(i({ref:n},c),{},{components:t})):l.a.createElement(b,i({ref:n},c))}));function b(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,o=new Array(a);o[0]=f;var i={};for(var d in n)hasOwnProperty.call(n,d)&&(i[d]=n[d]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var c=2;c<a;c++)o[c]=t[c];return l.a.createElement.apply(null,o)}return l.a.createElement.apply(null,t)}f.displayName="MDXCreateElement"}}]);